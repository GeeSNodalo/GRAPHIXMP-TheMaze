<html>
	<head>
		<title>The Maze - Final Puzzle</title>
	</head>


	<body>
		<script src="js/three.js"></script>
    	<script src="js/CanvasRenderer.js"></script>
    	<script src="js/Projector.js"></script>
    	<script src="js/OrbitControls.js"></script>
  
		<script>
            /* Giselle Nodalo; Gab Santiago GRAPHIX MP */ 
			var scene = new THREE.Scene();

			ambientLight = new THREE.AmbientLight( 0xFFFFFF, 0.2 );
		    scene.add( ambientLight );

		    hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.2);
		    scene.add( hemisphereLight );

		    directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
		    directionalLight.position.set( 10, 10, 10 );
		    directionalLight.castShadow = true;
		    scene.add( directionalLight );

		    spotLight1 = new THREE.SpotLight( 0xffffff, 0.4 );
		    spotLight1.position.set( 100, 10, 100 );
		    spotLight1.castShadow = true;
		    spotLight1.shadowDarkness = 0.2;
		    scene.add( spotLight1 );

		    spotLight2 = new THREE.SpotLight( 0xffffff, 0.4 );
		    spotLight2.position.set( 100, 100, 100 );
		    spotLight2.castShadow = true;
		    spotLight2.shadowDarkness = 0.2;
		    scene.add( spotLight2 );

			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );
			renderer.setClearColor( 0x777777, 0.3 );

      document.addEventListener('keydown', Keyboard, false);

			window.addEventListener( 'resize', function()
      		{
        		renderer.setSize( window.innerWidth, window.innerHeight );
        		camera.aspect = window.innerWidth / window.innerHeight;
        		camera.updateProjectionMatrix( );
      		} );

        var floorTexture = new THREE.TextureLoader().load("textures/floortexture.jpg");
      floorTexture.wrapS = THREE.RepeatWrapping;
      floorTexture.wrapT = THREE.RepeatWrapping;
      floorTexture.repeat.set(30,30);

      var planeGeometry = new THREE.PlaneGeometry(10000, 10000);

      var planeMaterial = new THREE.MeshPhongMaterial({map: floorTexture, wireframe: false});

      floor = new THREE.Mesh(planeGeometry, planeMaterial);
      floor.rotation.x -= Math.PI / 2;
      floor.recieveShadow = true;
      floor.scale.set(0.09, 0.09, 0.09);
      scene.add(floor);
      floor.position.y = -10;

      		controls = new THREE.OrbitControls( camera, renderer.domElement );

      		var geometry = new THREE.BoxGeometry( 0.95, 0.95, 0.95 );

      		var material = new THREE.MeshLambertMaterial({
      			map:  new THREE.TextureLoader().load("textures/diamond.jpg")
      		});

      		var cube = new THREE.Mesh( geometry, material );
      		cube.position.x = 1;
      		cube.position.y = 1;
      		cube.position.z = 1;
      		scene.add( cube );

      		var selectedCubeGeometry = new THREE.BoxGeometry( 0.95, 0.95, 0.95 );

      		var selectedCubeMaterial = new THREE.MeshLambertMaterial({
      			color: 0x384E77,
      			transparent: true,
      			opacity: 0.5
      		});

      		var selectedCube = new THREE.Mesh( selectedCubeGeometry, selectedCubeMaterial );
      		selectedCube.position.x = 1;
      		selectedCube.position.y = -1;
      		selectedCube.position.z = -1;
      		scene.add( selectedCube );

      		var outerBoxGeometry = new THREE.BoxGeometry( 3, 3, 3 );

      		var outerBoxMaterial = new THREE.MeshLambertMaterial({
      			color: 0xffffff,
      			transparent: true,
      			opacity: 0
      		})

      		var cubeOuter = new THREE.Mesh( outerBoxGeometry, outerBoxMaterial );
      		scene.add( cubeOuter );

      		camera.position.z = 5;


          var fixedCubeTexture =  new THREE.TextureLoader().load("textures/normalcubetexture.jpg");

      		var fixedCubeGeometry = new THREE.BoxGeometry( 0.95, 0.95, 0.95 );

      		var fixedCubeMaterial = new THREE.MeshLambertMaterial( {map: fixedCubeTexture});

      		var fixedCubeCoordinates = [
      			{ x:-1, y:-1, z:-1 },
		        { x: 0, y:-1, z:-1 },
		        { x: 1, y:0, z:1 },
		        { x: 0, y:0, z:1 },
		        { x: 1, y:1, z:0 },
		        { x: -1, y:-1, z:0 },
		        { x: 0, y:-1, z:-1 },
		        { x: 1, y:0, z:-1 },
		        { x: -1, y:1, z:0 },
		        { x: -1, y:1, z:1 },
		        { x: 0, y:0, z:0 },
		        { x: -1, y:1, z:-1 },
		        { x: 1, y:-1, z:1 },
      		]

      		function createNewMeshObject(x, y, z) {
      			var fixedCube = new THREE.Mesh( fixedCubeGeometry, fixedCubeMaterial );
      			fixedCube.position.x = x;
      			fixedCube.position.y = y;
      			fixedCube.position.z = z;
      			return fixedCube;
      		}

      		fixedCubeCoordinates.map( box => {
      			scene.add(
      				createNewMeshObject(box.x, box.y, box.z)
      			);
      		});

      		function Keyboard() {
      			var speed = 1;
      			var old = {
      				x: cube.position.x,
      				y: cube.position.y,
      				z: cube.position.z
      			};

      			if (event.keyCode == 65)
      				cube.position.x -= speed;
      			else if (event.keyCode == 68)
      				cube.position.x += speed;
      			else if (event.keyCode == 87)
      				cube.position.y += speed;
      			else if (event.keyCode == 83)
      				cube.position.y -= speed;
      			else if (event.keyCode == 80)
      				cube.position.z -= speed;
      			else if (event.keyCode == 76)
      				cube.position.z += speed;

      			if ( cube.position.x > 1 || cube.position.y >1 || cube.position.z > 1 || cube.position.x < -1 || cube.position.y < -1 || cube.position.z < -1 ){
          			cube.position.x = old.x;
          			cube.position.y = old.y;
          			cube.position.z = old.z;
        		}

		        if ( cube.position.x == selectedCube.position.x && cube.position.y == selectedCube.position.y && cube.position.z == selectedCube.position.z ){
		          cube.material.color.setHex(0x70A9A1);

              // Giselle, put the end screen here
              alert("Game Complete! Thank you for playing!");
		        window.open("endScreen.html", "_blank")
                };

		        fixedCubeCoordinates.map( box => {
		          if (
		            box.x === cube.position.x &&
		            box.y === cube.position.y &&
		            box.z === cube.position.z
		          ) {
		            cube.position.x = old.x;
		            cube.position.y = old.y;
		            cube.position.z = old.z;
		          }
		        });

      		}

      window.addEventListener( 'resize', onWindowResize, false );
          
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
      }
			
			var render = function() {
				renderer.render( scene, camera );
			}

			var GameLoop = function() {
				requestAnimationFrame( GameLoop );
				render();
			}

			GameLoop();


		</script>
	</body>
